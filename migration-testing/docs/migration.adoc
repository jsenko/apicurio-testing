
[id="registry-migration_{context}"]
= Migration from {registry} {registry-v2} to 3.x

== Introduction
[role="_abstract"]
{registry} 3.x includes a redesigned data model, a reworked REST API, and a refreshed SDK ecosystem compared to the previous {registry} {registry-v2} release.
This section outlines the major changes between {registry} {registry-v2} and version 3.x so that you can plan your upgrade activities.

Because of the breaking changes in 3.x, there is no in-place upgrade. You must stand up a new 3.x deployment, migrate the persisted content, and update your client applications and automation.

When migrating to version 3.x, take the following areas into account:

=== Updated data model and governance
{registry} 3.x separates artifact metadata from version metadata and introduces first-class support for empty artifacts. These capabilities let you prepare governance metadata, rules, and branch structures before the first version exists. Additional highlights include:

* Artifact metadata is now managed independently from version metadata.
* Groups and artifacts can define custom labels to improve categorization.
* Users can create and manage custom branches, and the `latest` branch is implemented as a system managed branch.

=== Core v3 REST API
The v3 REST API focuses on consistency and discoverability:

* Group management now covers descriptions, owners, labels, and hierarchical rules.
* New search endpoints at `/search/groups` and `/search/versions` expand discovery.
* Version-focused endpoints streamline content management and require explicit `Content-Type` headers.
* A `dryRun` query parameter replaces the former `/test` endpoints.
* A dedicated Branch API enables multitrack artifact development.

=== Re-engineered Kafka storage variant
The KafkaSQL storage implementation is now optimized for stability and maintainability.
The new design reduces startup times for large installations.

=== Generated SDKs powered by Kiota
{registry} 3.x ships Kiota-generated SDKs that mirror the REST API structure across languages.
Updated libraries are available for Java, TypeScript, Python, and Go, providing lightweight, type-safe clients with minimal dependencies and consistent naming.


[id="migration-planning_{context}"]
== Migration planning

[role="_abstract"]
Successful migration requires careful planning to minimize downtime and ensure data consistency. This section covers downtime expectations, resource requirements, and strategies for a smooth transition from {registry} {registry-v2} to 3.x.

=== Downtime expectations

The migration approach you choose determines the amount of downtime your registry will experience:

*Zero-downtime migration (recommended):*

* Use a reverse proxy or load balancer (nginx, HAProxy, etc.) to manage traffic routing
* Run {registry} {registry-v2} and 3.x in parallel during migration
* Switch traffic from v2 to v3 after data migration completes
* *Read operation downtime:* 10-30 seconds (during traffic routing switchover)
* *Write operation downtime:* 30-45 minutes (during export and import)

*Traditional maintenance window:*

* Stop all client applications
* Export data from {registry} {registry-v2}
* Shut down {registry} {registry-v2}
* Deploy and configure {registry} 3.x
* Import data and validate
* Resume client applications
* *Total downtime:* 1-2 hours (depending on data volume)

The zero-downtime approach is strongly recommended for production environments.

=== Resource requirements

During migration, you will temporarily run both {registry} {registry-v2} and 3.x simultaneously. Plan for:

*Infrastructure:*

* Separate database instances for v2 and v3 (or different schemas in the same database)
* For KafkaSQL deployments: same Kafka cluster with different topic names
* Load balancer capacity for routing traffic
* Network connectivity between all components

*Storage requirements:*

* v2 database/storage: existing size
* v3 database/storage: approximately same size as v2 (plan for 110% of v2 size)
* Export file storage: approximately 10-20% of database size (compressed)

*Timeline:*

* Keep v2 running for 1-7 days after migration for rollback capability
* Total parallel operation period: 1-7 days
* Budget for staging environment testing before production migration

=== Rollback strategy

A key advantage of the parallel deployment approach is the ability to rollback if issues arise:

*Immediate rollback (within hours of migration):*

. Switch load balancer back to {registry} {registry-v2}
. Investigate issues with 3.x deployment
. Recovery time: 30-60 seconds

*Delayed rollback (days after migration):*

. Assess data created in 3.x since migration
. Options:
** Accept data loss and rollback to v2
** Fix issues and remain on v3 (preferred)

*Preventing rollback scenarios:*

* Test migration thoroughly in staging environment
* Validate data integrity before switching production traffic
* Run comprehensive smoke tests after migration

=== Data consistency considerations

To ensure 100% data consistency during migration:

*Enable read-only mode during export:*

{registry} {registry-v2} does not have a built-in read-only mode. Use your load balancer to block write operations (POST, PUT, PATCH, DELETE) while allowing read operations (GET, HEAD, OPTIONS) during the export process.

Example nginx configuration for read-only mode:

[source,nginx]
----
server {
    location / {
        if ($request_method !~ ^(GET|HEAD|OPTIONS)$) {
            return 405 "Registry temporarily in read-only mode for migration";
        }
        proxy_pass http://registry-v2:8080;
    }
}
----

*Impact during read-only period:*

* Read operations (schema lookups): continue normally
* Write operations (new schemas, updates): blocked with HTTP 405
* Kafka producers with auto-register: will fail to register new schemas
* Duration: 30-45 minutes (export and import period)

*After switching to {registry} 3.x:*

* Write operations automatically resume
* No configuration changes needed
* Full read/write functionality restored

=== Prerequisites checklist

Before beginning migration:

[cols="1,3",options="header"]
|===
| Requirement | Description

| Staging environment
| Test complete migration workflow before production

| Load balancer
| nginx, HAProxy, or similar for traffic management

| Administrative access
| Credentials for export/import API endpoints

| Database/storage
| Separate database instance or schema (or separate Kafka topic) for {registry} 3.x

| Backup
| Current backup of {registry-v2} data

| Rollback plan
| Documented procedure to revert to v2 if needed
|===

[id="recommended-migration-workflow_{context}"]
== Recommended migration workflow

[role="_abstract"]
This section provides a complete, phase-based workflow for migrating from {registry} {registry-v2} to 3.x with minimal downtime. Each phase includes specific steps and validation checkpoints to ensure a successful migration.

=== Overview

The recommended migration approach uses a load balancer to manage traffic routing, enabling near-zero downtime for read operations and a controlled read-only period for write operations during data export.

[literal]
....
┌────────────────────────────────────────────────────────────────┐
│                     Client Applications                        │
└───────────────────────────┬────────────────────────────────────┘
                            │
                            ↓
                    ┌───────────────┐
                    │ Load Balancer │  (nginx, HAProxy, etc.)
                    └───────┬───────┘
                            │
        ┌───────────────────┼───────────────────┐
        │ Phase 1-3         │      Phase 4+     │
        ↓                   ↓                   ↓
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  Registry 2.x │   │  Registry 2.x │   │  Registry 3.x │
│   + Storage   │   │   + Storage   │   │   + Storage   │
└───────────────┘   └───────────────┘   └───────────────┘
    (read/write)        (read-only)         (read/write)
....

=== Phase 1: Preparation
NOTE: We recommend testing as much of the migration as possible in a staging environment before
upgrading in production.

==== Step 1: Deploy load balancer

If not already using a load balancer, deploy nginx or HAProxy in front of your existing {registry-v2} deployment:

. Deploy load balancer
. Configure to route traffic to {registry-v2}
. Update client applications to connect through load balancer
. Validate all traffic flows correctly

See xref:migrating-registry-configuration_{context}[Updating registry configuration] for load balancer configuration examples.

==== Step 2: Prepare {registry} 3.x infrastructure

Deploy the infrastructure for {registry} 3.x without starting the registry itself:

* *For SQL storage:* Deploy separate database instance or create separate schema
* *For KafkaSQL storage:* Use same Kafka cluster but configure different topic name
* Prepare TLS certificates (can reuse {registry-v2} certificates)
* Configure OAuth2/OIDC authentication provider

See xref:migrating-registry-configuration_{context}[Updating registry configuration] for detailed configuration changes.

*Checkpoint:* v2 traffic flowing through load balancer, v3 infrastructure ready.

=== Phase 2: Pre-migration validation

==== Step 3: Enable read-only mode

Configure the load balancer to block write operations while allowing read operations. This ensures no data changes occur during export.

Update your load balancer configuration to block POST, PUT, PATCH, and DELETE methods:

[source,nginx]
----
# nginx read-only configuration
server {
    location / {
        if ($request_method !~ ^(GET|HEAD|OPTIONS)$) {
            return 405 "Registry temporarily in read-only mode for migration";
        }
        proxy_pass http://registry-v2:8080;
    }
}
----

Reload the load balancer configuration and verify read-only mode is active.

*Impact:* Read operations (schema lookups) continue normally. Write operations (new schemas, updates) return HTTP 405. Kafka producers with auto-register will fail to register new schemas.

==== Step 4: Capture baseline metrics

Record the current state of your {registry-v2} deployment for comparison after migration.

Use the provided script to capture metrics pre-migration:

[source,bash]
----
./apicurio-capture-metrics.sh
----

The script captures:

* Total artifact count
* Sample of up to 5 artifacts with full metadata
* Global rule configurations
* Output saved to text file (default: `registry-baseline.txt`)

The script supports OAuth2 authentication and can be run interactively or automated using environment variables.

See xref:migration-scripts_{context}[Migration Scripts Reference] for detailed usage and configuration options.

*Checkpoint:* Read-only mode active, write operations blocked.  Baseline documented, ready for data migration.

=== Phase 3: Data migration

==== Step 5: Export data from {registry-v2}

Export data while the registry is in read-only mode. This produces a ZIP file containing all registry data.

Use the provided script to export data:

[source,bash]
----
./apicurio-export-registry-data.sh
----

The script:

* Exports all artifacts, versions, metadata, and rules from {registry-v2}
* Validates the exported ZIP file
* Reports file size and duration
* Supports OAuth2 authentication
* Default output: `registry-export.zip`

IMPORTANT: Access the registry directly (not through the load balancer) to bypass read-only restrictions on admin endpoints if needed.

See xref:migration-scripts_{context}[Migration Scripts Reference] for detailed usage and configuration options.

*Checkpoint:* Export complete, data snapshot captured.

==== Step 6: Deploy {registry} 3.x

Deploy {registry} 3.x using the infrastructure prepared in Step 2.  Make sure the v3 deployment is configured similarly to how the previous v2 deployment was configured.  Note that various configuration parameters have been renamed or otherwise changed.

See xref:migrating-registry-configuration_{context}[Updating registry configuration] for v3 configuration information and examples.

*Checkpoint:* {registry} 3.x deployed and healthy (empty, awaiting import).

==== Step 7: Import data into {registry} 3.x

Import the ZIP archive into the 3.x deployment:

[source,bash]
----
./apicurio-import-registry-data.sh
----

The script:

* Validates the import ZIP file
* Checks {registry} 3.x accessibility and version
* Imports all data from the export file
* Verifies artifact count after import
* Reports global rules configuration
* Supports OAuth2 authentication
* Default input: `registry-export.zip`

The import adds to existing data (does not replace). The script warns if the registry already contains artifacts.

See xref:migration-scripts_{context}[Migration Scripts Reference] for detailed usage and configuration options.

*Checkpoint:* Import complete, ready for validation.

==== Step 8: Validate import

Verify the {registry} 3.x deployment and confirm data migration was successful:

[source,bash]
----
./apicurio-verify-registry-version.sh
----

The script performs comprehensive verification:

* Health endpoint check
* System information retrieval
* Version verification (confirms 3.x)
* Artifact count comparison
* Global rules validation
* v2 API backward compatibility check (optional)

If validation fails, investigate import logs and re-attempt if necessary. Do not proceed to traffic switch until all checks pass.

See xref:migration-scripts_{context}[Migration Scripts Reference] for detailed usage and configuration options.

*Checkpoint:* v3 has all data, data metrics match v2, ready for traffic switch.

=== Phase 4: Traffic switch

==== Step 9: Switch load balancer to {registry} 3.x

Update the load balancer configuration to route to {registry} 3.x and enable read/write operations.  An example configuration using nginx might look like this:

[source,nginx]
----
# nginx v3 configuration (read/write enabled)
upstream registry {
    server registry-v3:8080;
}

server {
    location / {
        # All methods allowed
        proxy_pass http://registry;
        proxy_set_header Host $host;
    }
}
----

Reload the load balancer.

*Downtime:* This operation causes 10-30 seconds of downtime for all operations during the reload.

*Checkpoint:* All traffic routed to v3, write operations resumed.

==== Step 10: Verify traffic to the v3 deployment

Confirm traffic is flowing to {registry} 3.x through the load balancer:

[source,bash]
----
./apicurio-verify-registry-version.sh
----

The script confirms:

* {registry} is accessible through the load balancer
* Version is 3.x
* Health checks pass
* Artifact counts are correct
* Write operations are enabled (no longer read-only)

*Checkpoint:* Confirmed v3 is accessible and write operations working, no errors in logs.

=== Phase 5: Post-migration validation

==== Step 11: Test v2 API backward compatibility

Verify that v2 clients can access the 3.x registry through the v2 API compatibility layer.  All existing clients should continue operating normally (because Registry v3 still supports the v2 Core REST API used by v2 clients).

See xref:migrating-registry-applications_{context}[Migrating registry client applications] for detailed client migration guidance.

*Checkpoint:* v2 clients work correctly against v3 registry.

==== Step 12: Test v3 Core API functionality

Verify v3-specific API features work correctly:

[source,bash]
----
./apicurio-verify-v3-api-features.sh
----

The script tests v3-specific features:

* System endpoints (`/system/info`, `/system/limits`)
* Search endpoints (`/search/groups`, `/search/versions`)
* Admin endpoints
* Group operations
* Artifact operations
* Branch API (v3-specific)
* Version operations

The script provides a comprehensive test report with pass/fail status for each feature.

*Checkpoint:* v3 Core API features working correctly.

==== Step 13: Run smoke tests

Execute production smoke tests to validate critical functionality:

. Test critical client applications
. Verify Kafka SerDes applications work (if applicable)
. Check authentication and authorization
. Monitor error rates and performance metrics
. Validate no increase in 4xx/5xx errors

*Checkpoint:* All smoke tests passed, production traffic stable.

=== Phase 6: Stabilization

==== Step 14: Monitor and observe

Keep {registry-v2} running but not serving traffic for rollback capability:

* Monitor {registry} 3.x for 24-48 hours minimum
* Watch for error rates, performance issues, or unexpected behavior
* Be prepared for immediate rollback if critical issues arise (switch load balancer back to v2)
* Begin planning gradual client application migration to v3 SDKs

See xref:migrating-registry-applications_{context}[Migrating registry client applications] for guidance on updating client applications.

*Checkpoint:* v3 stable for 1-7 days, no rollback needed.

=== Phase 7: Cleanup

==== Step 15: Decommission {registry-v2}

After 1-7 days of successful operation on {registry} 3.x, decommission v2 infrastructure.

Update documentation to reflect v3 as the production registry.

*Checkpoint:* Migration complete, v2 decommissioned.

=== Troubleshooting migration issues

If you encounter issues during migration:

*Export fails:*

* Check authentication credentials are valid
* Verify {registry-v2} is accessible
* Review registry logs for errors

*Import fails:*

* Verify export file is valid ZIP format
* Check {registry} 3.x has sufficient storage
* Review registry v3 logs for specific errors
* If partial import occurred, drop v3 database and retry

*Baseline metrics mismatch:*

* Review import logs for skipped artifacts
* Check for import errors or warnings
* Verify export file integrity
* Consider re-exporting and re-importing

*Rollback needed:*

. Switch load balancer back to {registry-v2}
. Investigate v3 issues
. Recovery time: 30-60 seconds
. v2 data unchanged (export was read-only)

[id="migrating-registry-data_{context}"]
== Migrating {registry} data

[role="_abstract"]
Use the export and import APIs to migrate persisted content from {registry} {registry-v2} into a new {registry} 3.x deployment. The APIs preserve artifact identifiers, metadata, and references so that downstream Kafka payloads remain compatible.

IMPORTANT: The export/import procedure is *required* for migration. {registry} 3.x cannot directly read {registry-v2} storage:

* *SQL storage:* The v3 database schema is incompatible with v2
* *KafkaSQL storage:* The v3 Kafka journal topic format is incompatible with v2

You must export data from v2 and import it into v3 using the export/import APIs.

{registry} 3.x accepts the export archive generated from a {registry-v2} instance. Capture the archive from your existing deployment, provision the 3.x environment, and import the archive into the new cluster.

.Prerequisites
* Running {registry} instances of the {registry-v2} server you are exporting from and the 3.x server you are importing into.
* Administrative credentials that allow access to the `/apis/registry/v2/admin/export` and `/apis/registry/v3/admin/import` endpoints.
* If using OAuth2 authentication, valid client credentials with admin role (e.g., `sr-admin`).

.Procedure

The migration scripts automate the export, import, and validation process with support for OAuth2 authentication and detailed error handling.

. Export all data from {registry} {registry-v2} using the export script:
+
[source,bash]
----
./apicurio-export-registry-data.sh
----
+
The script will:
+
* Connect to your {registry-v2} deployment
* Export all artifacts, versions, metadata, and rules
* Save the data to a ZIP file (default: `registry-export.zip`)
* Validate the export file format and size
* Report export duration and file details
+
For detailed configuration options and OAuth2 authentication setup, see xref:migration-scripts_{context}[Migration Scripts Reference].

. Import the export archive into {registry} 3.x using the import script:
+
[source,bash]
----
./apicurio-import-registry-data.sh
----
+
The script will:
+
* Validate the import ZIP file exists and is valid
* Check {registry} 3.x accessibility and version
* Import all data from the export file
* Verify artifact counts before and after import
* Report global rules configuration
+
For detailed configuration options, see xref:migration-scripts_{context}[Migration Scripts Reference].

. Validate the imported data using the verification script:
+
[source,bash]
----
./apicurio-verify-registry-version.sh
----
+
The script performs comprehensive validation:
+
* Health endpoint verification
* System information and version check
* Artifact count comparison
* Global rules validation
* v2 API backward compatibility check (optional)
+
For detailed configuration options, see xref:migration-scripts_{context}[Migration Scripts Reference].

=== Manual procedure (without scripts)

If you prefer, you can also use the Registry UI to export from v2 and import into v3.

[role="_additional-resources"]
.Additional resources
* {LinkServiceRegistryUser}[{NameServiceRegistryUser}]


[id="migrating-registry-applications_{context}"]
== Migrating {registry} client applications

[role="_abstract"]
Review every application that integrates with {registry} {registry-v2} to ensure compatibility with the v3 REST API, SDKs, and client libraries. Update dependency coordinates, reconfigure endpoints, and adjust automation to account for the new data model.

.Prerequisites
* Existing {registry} {registry-v2} applications that rely on the v2 REST API or legacy client libraries.
* Access to the source code or deployment configuration for each application you must update.

.Procedure
. Update your client configuration to target the v3 REST API base path:
+
[source,java]
----
String registryUrl = "https://new-registry.my-company.com/apis/registry/v3";
RegistryClient client = RegistryClientFactory.create(registryUrl);
----
+
Automation that previously targeted `/apis/registry/v2` continues to function, but new functionality is only exposed through the v3 API.

. Refresh your client dependencies to the latest 3.x SDKs generated with Kiota. For Maven-based Java applications, use the new artifact identifier:
+
[source,xml,subs="attributes+"]
----
<dependency>
    <groupId>io.apicurio</groupId>
    <artifactId>apicurio-registry-java-sdk</artifactId>
    <version>{registry-release}</version>
</dependency>
----
+
Install the TypeScript, Python, or Go SDKs through the respective package managers (`npm install @apicurio/apicurio-registry-sdk`, `pip install apicurioregistrysdk`, or `go get github.com/apicurio/apicurio-registry/go-sdk`).

. Align your integration code with the reorganized endpoints:
* Manage artifact metadata at `/groups/{groupId}/artifacts/{artifactId}`.
* Retrieve or create content exclusively through `/versions` endpoints.
* Replace calls to `/test` endpoints with the `dryRun` query parameter.
* Use `/search/groups` and `/search/versions` where you previously enumerated artifacts indirectly.

. Adopt the branch API if you need parallel development streams. Branches allow you to promote or merge versions without duplicating artifacts.

. If you build Kafka SerDes integrations, verify that serializers and deserializers still reference the correct registry URL and consider enabling group- or artifact-level rules introduced in 3.x to enforce compatibility upstream.

[role="_additional-resources"]
.Additional resources
* {LinkServiceRegistryUser}[{NameServiceRegistryUser}]


[id="migrating-registry-configuration_{context}"]
== Updating {registry} configuration

[role="_abstract"]
Configuration keys in {registry} 3.x adopt a unified `apicurio.` namespace and reorganize authentication, eventing, UI, and storage settings. Review and update your deployment descriptors so that server-side properties match the new naming scheme.

=== Naming convention changes
Most configuration properties now start with the `apicurio.` prefix. The following examples illustrate common mappings:

[cols="1,1",options="header"]
|===
| Registry 2.x property
| Registry 3.x property

| `registry.auth.roles.admin`
| `apicurio.auth.roles.admin`

| `registry.events.kafka.topic`
| `apicurio.events.kafka.topic`

| `registry.rest.artifact.deletion.enabled`
| `apicurio.rest.deletion.artifact.enabled`
|===

=== Authentication and authorization
Authentication settings continue to rely on Quarkus OIDC support, but role-based properties moved to the new namespace. Update the property names and review any removed options:

[cols="1,1",options="header"]
|===
| Registry 2.x property
| Registry 3.x property

| `registry.auth.enabled`
| `quarkus.oidc.enabled`

| `registry.auth.role-source`
| `apicurio.auth.role-source`

| `registry.auth.anonymous-read-access.enabled`
| `apicurio.auth.anonymous-read-access.enabled`

| `registry.auth.oidc.client-id`
| `quarkus.oidc.client-id`

| `registry.auth.oidc.token-endpoint`
| `quarkus.oidc.token-path`
|===

[source,properties]
----
# Registry 2.x
registry.auth.enabled=true
registry.auth.roles.admin=admin
registry.auth.oidc.client-id=my-client

# Registry 3.x
quarkus.oidc.enabled=true
apicurio.auth.roles.admin=admin
quarkus.oidc.client-id=my-client
----

=== Eventing and Kafka storage
Kafka-related settings now share the `apicurio.kafkasql` prefix. Update both event notifications and Kafka storage properties:

[cols="1,1",options="header"]
|===
| Registry 2.x property
| Registry 3.x property

| `registry.events.kafka.topic`
| `apicurio.events.kafka.topic`

| `registry.kafkasql.bootstrap.servers`
| `apicurio.kafkasql.bootstrap.servers`

| `registry.kafkasql.topic.auto-create`
| `apicurio.kafkasql.topic.auto-create`
|===

[source,properties]
----
# Registry 3.x example
apicurio.events.kafka.topic=my-registry-events
apicurio.kafkasql.bootstrap.servers=kafka:9092
apicurio.kafkasql.topic=my-registry-storage
apicurio.kafkasql.topic.auto-create=true
----

=== UI and API configuration
The UI configuration is now grouped under `apicurio.ui.*`, and API diagnostics align with the new hierarchy:

[cols="1,1",options="header"]
|===
| Registry 2.x property
| Registry 3.x property

| `registry.ui.contextPath`
| `apicurio.ui.contextPath`

| `registry.ui.features.readOnly`
| `apicurio.ui.features.read-only.enabled`

| `registry.ui.auth.oidc.redirect-url`
| `apicurio.ui.auth.oidc.redirect-uri`

| `registry.api.errors.include-stack-in-response`
| `apicurio.api.errors.include-stack-in-response`
|===

=== Storage and database configuration
Database settings moved out of the Quarkus datasource namespace. Update JDBC configuration and storage selection properties:

[cols="1,1",options="header"]
|===
| Registry 2.x property
| Registry 3.x property

| `quarkus.datasource.jdbc.url`
| `apicurio.datasource.url`

| `quarkus.datasource.username`
| `apicurio.datasource.username`

| `registry.sql.init`
| `apicurio.sql.init`

| `registry.storage.kind`
| `apicurio.storage.kind`
|===

=== Migration checklist

. Inventory all configuration files, including deployment manifests and `application.properties`.
. Translate properties to their 3.x equivalents using the mappings in this section.
. Start a staging deployment of {registry} 3.x with the updated configuration and monitor logs for deprecated or unknown keys.
. Validate UI login flows, rule enforcement, and storage connectivity before promoting to production.

=== Common issues and resolutions
* *Authentication failures*: confirm that `apicurio.auth.roles.*` properties mirror the expected role names and that OIDC redirect URIs use the new property names.
* *Missing Kafka settings*: verify that all Kafka-related properties use the `apicurio.kafkasql` prefix and that optional settings removed in 3.x are not still present.
* *Database connection errors*: ensure you migrated JDBC settings out of the `quarkus.datasource.*` namespace and updated secrets or ConfigMaps accordingly.

[role="_additional-resources"]
.Additional resources
* {LinkServiceRegistryUser}[{NameServiceRegistryUser}]


[id="migration-scripts_{context}"]
== Migration scripts reference

[role="_abstract"]
This section provides reference documentation for the migration scripts that automate key steps in the migration workflow. All scripts support both interactive mode and automated mode using environment variables, and include OAuth2 authentication support.

=== Overview

The migration scripts are designed to be production-ready tools that handle the most critical and error-prone aspects of migration:

* **apicurio-capture-metrics.sh** - Captures metrics before/after migration (for comparison)
* **apicurio-export-registry-data.sh** - Exports all data from {registry-v2}
* **apicurio-import-registry-data.sh** - Imports data into {registry} 3.x
* **apicurio-verify-registry-version.sh** - Verifies registry version and health
* **apicurio-verify-v3-api-features.sh** - Tests v3-specific API features

All scripts can be found in the Apicurio Registry GitHub repository under `migration-testing/docs/scripts/`.

=== Common features

All migration scripts share these common features:

*Interactive and automated modes:*

* Interactive mode: Scripts prompt for required inputs with sensible defaults
* Automated mode: Set environment variables to skip prompts (useful for CI/CD)

*OAuth2 authentication support:*

* Client credentials grant type
* Configurable token endpoint and client credentials
* Optional: Run without authentication for testing environments

*TLS/HTTPS support:*

* Works with trusted certificates by default
* Option to skip TLS verification for development/testing (`SKIP_TLS_VERIFY=true`)

*Clear output and error handling:*

* Color-coded output (info, success, warning, error)
* Detailed progress indicators
* Clear exit codes for automation (0 = success, 1 = failure)

=== Script: apicurio-capture-metrics.sh

*Purpose:* Captures metrics from registry before and after migration.

*What it captures:*

* Total artifact count
* Sample of up to 5 artifacts with full metadata
* Global rule configurations
* Output saved to text file for post-migration comparison

*Usage (interactive):*

[source,bash]
----
./apicurio-capture-metrics.sh
----

*Usage (automated):*

[source,bash]
----
export REGISTRY_URL="https://registry.example.com"
export REGISTRY_API_VERSION="v2"
export AUTH_ENABLED="true"
export AUTH_TOKEN_URL="https://keycloak.example.com/realms/registry/protocol/openid-connect/token"
export AUTH_CLIENT_ID="admin-client"
export AUTH_CLIENT_SECRET="your-secret"
export OUTPUT_FILE="registry-baseline.txt"

./apicurio-capture-metrics.sh
----

*Environment variables:*

[cols="1,2",options="header"]
|===
| Variable
| Description

| `REGISTRY_URL`
| Registry base URL (e.g., `https://registry.example.com`)

| `REGISTRY_API_VERSION`
| API version to use (default: `v2`)

| `AUTH_ENABLED`
| Set to `true` to enable OAuth2 authentication

| `AUTH_TOKEN_URL`
| OAuth2 token endpoint URL

| `AUTH_CLIENT_ID`
| OAuth2 client ID

| `AUTH_CLIENT_SECRET`
| OAuth2 client secret

| `OUTPUT_FILE`
| Output file path (default: `registry-baseline.txt`)

| `SKIP_TLS_VERIFY`
| Set to `true` to skip TLS certificate verification
|===

*Output:*

Text file containing artifact summary and global rules (default: `registry-metrics.txt`).

=== Script: apicurio-export-registry-data.sh

*Purpose:* Exports all data from {registry-v2} deployment to a ZIP file.

*What it exports:*

* All artifacts and versions
* Artifact metadata (labels, properties, descriptions)
* Global and artifact-specific rules
* Artifact references

*Usage (interactive):*

[source,bash]
----
./apicurio-export-registry-data.sh
----

*Usage (automated):*

[source,bash]
----
export REGISTRY_URL="https://registry-v2.example.com"
export REGISTRY_API_VERSION="v2"
export AUTH_ENABLED="true"
export AUTH_TOKEN_URL="https://keycloak.example.com/realms/registry/protocol/openid-connect/token"
export AUTH_CLIENT_ID="admin-client"
export AUTH_CLIENT_SECRET="your-secret"
export EXPORT_FILE="registry-export.zip"

./apicurio-export-registry-data.sh
----

*Environment variables:*

[cols="1,2",options="header"]
|===
| Variable
| Description

| `REGISTRY_URL`
| Registry base URL (e.g., `https://registry-v2.example.com`)

| `REGISTRY_API_VERSION`
| API version to use (default: `v2`)

| `AUTH_ENABLED`
| Set to `true` to enable OAuth2 authentication

| `AUTH_TOKEN_URL`
| OAuth2 token endpoint URL

| `AUTH_CLIENT_ID`
| OAuth2 client ID

| `AUTH_CLIENT_SECRET`
| OAuth2 client secret

| `EXPORT_FILE`
| Export file path (default: `registry-export.zip`)

| `SKIP_TLS_VERIFY`
| Set to `true` to skip TLS certificate verification
|===

*Output:*

ZIP file containing complete registry export (default: `registry-export.zip`).

*Important notes:*

* Run this script while the registry is in read-only mode to ensure data consistency
* The export file can be large depending on registry size

=== Script: apicurio-import-registry-data.sh

*Purpose:* Imports data from a v2 export file into {registry} 3.x deployment.

*What it does:*

* Validates the import ZIP file
* Checks {registry} 3.x accessibility and version
* Imports all data from the export file
* Verifies artifact count after import
* Reports global rules configuration

*Usage (interactive):*

[source,bash]
----
./apicurio-import-registry-data.sh
----

*Usage (automated):*

[source,bash]
----
export REGISTRY_URL="https://registry-v3.example.com"
export REGISTRY_API_VERSION="v3"
export AUTH_ENABLED="true"
export AUTH_TOKEN_URL="https://keycloak.example.com/realms/registry/protocol/openid-connect/token"
export AUTH_CLIENT_ID="admin-client"
export AUTH_CLIENT_SECRET="your-secret"
export IMPORT_FILE="registry-export.zip"

./apicurio-import-registry-data.sh
----

*Environment variables:*

[cols="1,2",options="header"]
|===
| Variable
| Description

| `REGISTRY_URL`
| Registry base URL (e.g., `https://registry-v3.example.com`)

| `REGISTRY_API_VERSION`
| API version to use (default: `v3`)

| `AUTH_ENABLED`
| Set to `true` to enable OAuth2 authentication

| `AUTH_TOKEN_URL`
| OAuth2 token endpoint URL

| `AUTH_CLIENT_ID`
| OAuth2 client ID

| `AUTH_CLIENT_SECRET`
| OAuth2 client secret

| `IMPORT_FILE`
| Import file path (default: `registry-export.zip`)

| `SKIP_TLS_VERIFY`
| Set to `true` to skip TLS certificate verification
|===

*Important notes:*

* Import adds to existing data (does not replace)
* Script warns if registry already contains artifacts
* Recommended to import into empty v3 registry

=== Script: apicurio-verify-registry-version.sh

*Purpose:* Verifies the version and health of a {registry} deployment.

*What it checks:*

* Health endpoint (200 OK)
* System information retrieval
* Version verification (2.x or 3.x)

*Usage (interactive):*

[source,bash]
----
./apicurio-verify-registry-version.sh
----

*Usage (automated):*

[source,bash]
----
export REGISTRY_URL="https://registry.example.com"
export REGISTRY_VERSION="v3"
export AUTH_ENABLED="true"
export AUTH_TOKEN_URL="https://keycloak.example.com/realms/registry/protocol/openid-connect/token"
export AUTH_CLIENT_ID="admin-client"
export AUTH_CLIENT_SECRET="your-secret"

./apicurio-verify-registry-version.sh
----

*Environment variables:*

[cols="1,2",options="header"]
|===
| Variable
| Description

| `REGISTRY_URL`
| Registry base URL (e.g., `https://registry.example.com`)

| `REGISTRY_VERSION`
| Registry version to test (default: `v3`)

| `AUTH_ENABLED`
| Set to `true` to enable OAuth2 authentication

| `AUTH_TOKEN_URL`
| OAuth2 token endpoint URL

| `AUTH_CLIENT_ID`
| OAuth2 client ID

| `AUTH_CLIENT_SECRET`
| OAuth2 client secret

| `SKIP_TLS_VERIFY`
| Set to `true` to skip TLS certificate verification
|===

*Exit codes:*

* `0` - All checks passed
* `1` - One or more checks failed

=== Script: apicurio-verify-v3-api-features.sh

*Purpose:* Verifies that v3-specific API features are available and functioning correctly.

*What it tests:*

* v3 system endpoints (`/system/info`, `/system/limits`)
* v3 search endpoints (`/search/groups`, `/search/versions`)
* Admin endpoints

*Usage (interactive):*

[source,bash]
----
./apicurio-verify-v3-api-features.sh
----

*Usage (automated):*

[source,bash]
----
export REGISTRY_URL="https://registry-v3.example.com"
export AUTH_ENABLED="true"
export AUTH_TOKEN_URL="https://keycloak.example.com/realms/registry/protocol/openid-connect/token"
export AUTH_CLIENT_ID="admin-client"
export AUTH_CLIENT_SECRET="your-secret"

./apicurio-verify-v3-api-features.sh
----

*Environment variables:*

[cols="1,2",options="header"]
|===
| Variable
| Description

| `REGISTRY_URL`
| Registry base URL (e.g., `https://registry-v3.example.com`)

| `AUTH_ENABLED`
| Set to `true` to enable OAuth2 authentication

| `AUTH_TOKEN_URL`
| OAuth2 token endpoint URL

| `AUTH_CLIENT_ID`
| OAuth2 client ID

| `AUTH_CLIENT_SECRET`
| OAuth2 client secret

| `SKIP_TLS_VERIFY`
| Set to `true` to skip TLS certificate verification
|===

*Exit codes:*

* `0` - All feature tests passed
* `1` - One or more feature tests failed

=== Authentication

All scripts support OAuth2 authentication with client credentials grant type.

*Interactive mode (prompts):*

If environment variables are not set, scripts will prompt for:

* Auth token endpoint URL
* Client ID
* Client secret (hidden input)

*Automated mode (environment variables):*

For automation, set these environment variables:

[source,bash]
----
export AUTH_ENABLED="true"
export AUTH_TOKEN_URL="https://keycloak.example.com/realms/registry/protocol/openid-connect/token"
export AUTH_CLIENT_ID="admin-client"
export AUTH_CLIENT_SECRET="your-secret"
----

*Unauthenticated deployments:*

If your {registry} does not use authentication:

[source,bash]
----
export AUTH_ENABLED="false"
----

Or simply press Enter when prompted for authentication.

=== TLS/HTTPS support

*Production (trusted certificates):*

Scripts work with trusted certificates by default:

[source,bash]
----
export SKIP_TLS_VERIFY="false"
----

*Development (self-signed certificates):*

For testing with self-signed certificates:

[source,bash]
----
export SKIP_TLS_VERIFY="true"
----

WARNING: Only use `SKIP_TLS_VERIFY=true` in non-production environments.

=== Troubleshooting scripts

*Issue: "Failed to obtain access token"*

Solution:

* Verify `AUTH_TOKEN_URL` is correct
* Check client credentials are valid
* Ensure client has appropriate roles (e.g., `sr-admin`)
* Test manually with curl

*Issue: "Registry is not accessible"*

Solution:

* Verify `REGISTRY_URL` is correct
* Check network connectivity
* Ensure registry is running and healthy
* Verify firewall/security group rules

*Issue: "Export file is too small"*

Solution:

* Check authentication is working
* Verify admin permissions
* Review registry logs for errors
* Ensure export endpoint is accessible

*Issue: "Import failed"*

Solution:

* Verify export file is valid ZIP: `unzip -t registry-export.zip`
* Check registry v3 has sufficient storage
* Review registry v3 logs for errors
* Ensure registry v3 is healthy before import

*Issue: "Artifact count mismatch"*

Solution:

* Wait a few seconds after import (processing delay)
* Check import logs for errors
* Verify export file integrity
* Consider re-exporting and re-importing

=== Dependencies

All scripts require:

* `bash` (version 4.0+)
* `curl`
* `jq` (for JSON parsing)
* `unzip` (optional, for ZIP validation)

[role="_additional-resources"]
.Additional resources
* {LinkServiceRegistryUser}[{NameServiceRegistryUser}]
